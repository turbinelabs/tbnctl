package main

import (
	"bytes"

	"github.com/turbinelabs/api"
	"github.com/turbinelabs/api/objecttype"
	"github.com/turbinelabs/api/service"
	"github.com/turbinelabs/codec"
)

type __type__Adapter struct {
	service.__Type__
}

var _ typelessIface = __type__Adapter{}

func (_ __type__Adapter) Type() objecttype.ObjectType {
	return objecttype.__Type__
}

func (a __type__Adapter) Create(o interface{}) (interface{}, error) {
	return a.__Type__.Create(o.(api.__Type__))
}

func (a __type__Adapter) Get(k string) (interface{}, error) {
	return a.__Type__.Get(api.__Type__Key(k))
}

func (a __type__Adapter) Modify(nxt interface{}) (interface{}, error) {
	return a.__Type__.Modify(nxt.(api.__Type__))
}

func (a __type__Adapter) Delete(k string, cs api.Checksum) error {
	return a.__Type__.Delete(api.__Type__Key(k), cs)
}

func (a __type__Adapter) Index() ([]interface{}, error) {
	objs, err := a.__Type__.Index()
	if err != nil {
		return nil, err
	}

	result := make([]interface{}, 0, len(objs))
	for i := range objs {
		result = append(result, objs[i])
	}

	return result, nil
}

func (a __type__Adapter) Zero() interface{} {
	return api.__Type__{}
}

func (a __type__Adapter) ObjFromString(s string, cd codec.Codec) (interface{}, error) {
	dest := api.__Type__{}
	r := bytes.NewReader([]byte(s))
	err := cd.Decode(r, &dest)
	return dest, err
}

func (a __type__Adapter) Checksum(o interface{}) api.Checksum {
	return o.(api.__Type__).Checksum
}

func mkGet__Type__(svc *unifiedSvc) func(k api.__Type__Key) (api.__Type__, error) {
	cache := map[api.__Type__Key]api.__Type__{}
	return func(k api.__Type__Key) (api.__Type__, error) {
		if o, ok := cache[k]; ok {
			return o, nil
		}

		o, err := svc.__Type__().Get(k)
		if err == nil {
			cache[k] = o
		}
		return o, err
	}
}

// underlying allows introspection to the underlying interface for testing
// purposes
func (a __type__Adapter) underlying() interface{} {
	return a.__Type__
}
